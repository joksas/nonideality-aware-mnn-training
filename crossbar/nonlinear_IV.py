import math

import tensorflow as tf

from . import utils


def compute_I_all(
    V: tf.Tensor, G: tf.Tensor, V_ref: float, n_avg: float, n_std: float = 0.0
) -> tuple[tf.Tensor, tf.Tensor]:
    """Compute output currents of a crossbar consisting of devices suffering from I-V
    nonlinearities.

    Args:
        V: Voltages of shape `p x m`.
        G: Conductances of shape `m x n`.
        V_ref: Voltage at which the devices behave ohmically.
        n_avg: Average value of nonlinearity parameter.
        n_std: Standard deviation of non-linearity parameter.

    Returns:
        I: Output currents of shape `p x n`.
        I_ind: Currents of shape `p x m x n` produced by each of the conductances in the crossbar
            array.
    """
    I_ind = compute_currents(n_avg, V_ref, G, V, n_std=n_std)
    I = utils.add_I_BL(I_ind)

    return I, I_ind


def compute_currents(
    n_avg: float, V_ref: float, G: tf.Tensor, V: tf.Tensor, n_std: float = 0.0
) -> tf.Tensor:
    """Compute current values by modelling I-V behaviour using nonlinearity parameter.

    Nonlinearity parameter `n` is defined as the current generated by a resistive device at voltage
    `2*V` divided by the current generated by the device at voltage `V`. We introduce voltage
    `V_ref` at which the generated amount of current equals the expected amount described by Ohm's
    law, i.e. `I = V*G`.

    Args:
        n_avg: Average value of nonlinearity parameter.
        V_ref: Voltage at which the devices behave ohmically.
        G: Conductances of shape `m x n`.
        V: Voltages of shape `p x m`.
        n_std: Standard deviation of nonlinearity parameter.

    Returns:
        Currents of shape `p x m x n` produced by each of the conductances in the crossbar array.
    """
    n = tf.random.normal(G.get_shape().as_list(), mean=n_avg, stddev=n_std)
    # n <= 1 would produce unrealistic behaviour, while 1 < n < 2 is not typical in I-V curves
    n = tf.clip_by_value(n, 2.0, math.inf)

    ohmic_current = V_ref * tf.expand_dims(G, axis=0)
    # Take absolute value of V to prevent negative numbers from being raised to
    # a negative power. We assume symmetrical behaviour with negative voltages.
    ratio = tf.expand_dims(tf.abs(V) / V_ref, axis=-1)
    exponent = utils.tf_log2(n)
    sign = tf.expand_dims(tf.sign(V), axis=-1)

    I = sign * ohmic_current * ratio ** exponent

    return I
